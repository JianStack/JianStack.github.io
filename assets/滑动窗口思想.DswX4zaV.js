import{_ as m}from"./ValaxyMain.vue_vue_type_style_index_0_lang.Dl6f09j6.js";import{e as f,a as g,u as b}from"./chunks/vue-router.OX6wyTgk.js";import{N as x,a3 as a,U as t,S as l,W as n,u as v,O as k,E as y}from"./framework.CGpsDzRo.js";import"./app.JH9xSBGv.js";import"./chunks/dayjs.CCYrSalk.js";import"./chunks/@vueuse/motion.Cj-llAHY.js";import"./chunks/vue-i18n.BIKvsUT3.js";import"./chunks/pinia.DIgot8h-.js";import"./chunks/nprogress.BahbDzmd.js";import"./YunComment.vue_vue_type_style_index_0_lang.GypxAZnc.js";import"./index.C5okkQwF.js";import"./YunPageHeader.vue_vue_type_script_setup_true_lang.DnrUgoOv.js";import"./post.CQKmAQPh.js";const $=f("/posts/滑动窗口思想",async i=>JSON.parse('{"title":"滑动窗口思想","description":"","frontmatter":{"title":"滑动窗口思想","date":"2025-07-29","updated":"2025-07-29","categories":"技术分享","tags":["力扣","学习","算法","开发技巧"],"top":1},"headers":[],"relativePath":"pages/posts/滑动窗口思想.md","lastUpdated":1755313729000}'),{lazy:(i,r)=>i.name===r.name}),D={__name:"滑动窗口思想",setup(i,{expose:r}){var p;const{data:o}=$(),d=b(),u=g(),s=Object.assign(u.meta.frontmatter||{},((p=o.value)==null?void 0:p.frontmatter)||{});return u.meta.frontmatter=s,d.currentRoute.value.data=o.value,y("valaxy:frontmatter",s),globalThis.$frontmatter=s,r({frontmatter:{title:"滑动窗口思想",date:"2025-07-29",updated:"2025-07-29",categories:"技术分享",tags:["力扣","学习","算法","开发技巧"],top:1}}),(e,c)=>{const h=m;return k(),x(h,{frontmatter:v(s)},{"main-content-md":a(()=>c[0]||(c[0]=[l("h2",{id:"滑动窗口算法详解-解决无重复字符的最长子串问题",tabindex:"-1"},[n("滑动窗口算法详解：解决无重复字符的最长子串问题 "),l("a",{class:"header-anchor",href:"#滑动窗口算法详解-解决无重复字符的最长子串问题","aria-label":'Permalink to "滑动窗口算法详解：解决无重复字符的最长子串问题"'},"​")],-1),l("h3",{id:"问题描述",tabindex:"-1"},[n("问题描述 "),l("a",{class:"header-anchor",href:"#问题描述","aria-label":'Permalink to "问题描述"'},"​")],-1),l("p",null,[n("给定一个字符串 "),l("code",null,"s"),n("，找出其中不含有重复字符的 "),l("strong",null,"最长子串"),n(" 的长度。例如：")],-1),l("ul",null,[l("li",null,[n("输入 "),l("code",null,'s = "abcabcbb"'),n("，输出 "),l("code",null,"3"),n('（最长子串 "abc"）')]),l("li",null,[n("输入 "),l("code",null,'s = "bbbbb"'),n("，输出 "),l("code",null,"1"),n('（最长子串 "b"）')]),l("li",null,[n("输入 "),l("code",null,'s = "pwwkew"'),n("，输出 "),l("code",null,"3"),n('（最长子串 "wke" 或 "kew"）')])],-1),l("h3",{id:"什么是滑动窗口算法",tabindex:"-1"},[n("什么是滑动窗口算法？ "),l("a",{class:"header-anchor",href:"#什么是滑动窗口算法","aria-label":'Permalink to "什么是滑动窗口算法？"'},"​")],-1),l("p",null,[n("滑动窗口是一种高效解决数组/字符串子区间问题的算法。它通过维护一个可动态扩展/收缩的窗口（由左右指针定义），在遍历过程中更新窗口状态并记录最优解。该算法通常能在 "),l("strong",null,"O(n)"),n(" 时间复杂度内解决问题。")],-1),l("h3",{id:"算法思路",tabindex:"-1"},[n("算法思路 "),l("a",{class:"header-anchor",href:"#算法思路","aria-label":'Permalink to "算法思路"'},"​")],-1),l("ol",null,[l("li",null,[l("strong",null,"初始化"),n("：左指针 "),l("code",null,"left = 0"),n("，最大长度 "),l("code",null,"maxLen = 0")]),l("li",null,[l("strong",null,"遍历字符串"),n("（右指针 "),l("code",null,"right"),n(" 从 0 开始）： "),l("ul",null,[l("li",null,[n("若当前字符未出现在窗口中： "),l("ul",null,[l("li",null,"将其加入窗口"),l("li",null,[n("更新最大长度："),l("code",null,"maxLen = max(maxLen, 窗口长度)")]),l("li",null,"右指针右移")])]),l("li",null,[n("若当前字符已在窗口中： "),l("ul",null,[l("li",null,"移除左指针指向的字符"),l("li",null,"左指针右移")])])])]),l("li",null,[l("strong",null,"返回结果"),n("："),l("code",null,"maxLen")])],-1),l("h3",{id:"优化-快速跳转左指针",tabindex:"-1"},[n("优化：快速跳转左指针 "),l("a",{class:"header-anchor",href:"#优化-快速跳转左指针","aria-label":'Permalink to "优化：快速跳转左指针"'},"​")],-1),l("p",null,[n("在基础实现中，左指针每次只移动一步。我们可以通过 "),l("strong",null,"记录字符最后出现的位置"),n(" 来优化：")],-1),l("ul",null,[l("li",null,[n("使用 "),l("code",null,"Map<Character, Integer>"),n(" 存储字符及其最后出现的位置")]),l("li",null,[n("当遇到重复字符时，直接跳转左指针： "),l("code",null,"left = max(left, 重复字符最后位置 + 1)")])],-1),l("h3",{id:"代码实现-两种方法",tabindex:"-1"},[n("代码实现（两种方法） "),l("a",{class:"header-anchor",href:"#代码实现-两种方法","aria-label":'Permalink to "代码实现（两种方法）"'},"​")],-1),l("h4",{id:"方法1-基础实现-逐步移动左指针",tabindex:"-1"},[n("方法1：基础实现（逐步移动左指针） "),l("a",{class:"header-anchor",href:"#方法1-基础实现-逐步移动左指针","aria-label":'Permalink to "方法1：基础实现（逐步移动左指针）"'},"​")],-1),l("p",null,"java",-1),l("div",{class:"language- vp-adaptive-theme"},[l("button",{title:"Copy Code",class:"copy"}),l("span",{class:"lang"}),l("pre",{class:"shiki shiki-themes github-light github-dark vp-code"},[l("code",{"v-pre":""},[l("span",{class:"line"},[l("span",null,"class Solution {")]),n(`
`),l("span",{class:"line"},[l("span",null,"    public int lengthOfLongestSubstring(String s) {")]),n(`
`),l("span",{class:"line"},[l("span",null,"        Set<Character> set = new HashSet<>();")]),n(`
`),l("span",{class:"line"},[l("span",null,"        int left = 0, right = 0, maxLen = 0;")]),n(`
`),l("span",{class:"line"},[l("span",null,"        while (right < s.length()) {")]),n(`
`),l("span",{class:"line"},[l("span",null,"            char c = s.charAt(right);")]),n(`
`),l("span",{class:"line"},[l("span",null,"            if (!set.contains(c)) {")]),n(`
`),l("span",{class:"line"},[l("span",null,"                set.add(c);")]),n(`
`),l("span",{class:"line"},[l("span",null,"                maxLen = Math.max(maxLen, right - left + 1);")]),n(`
`),l("span",{class:"line"},[l("span",null,"                right++;")]),n(`
`),l("span",{class:"line"},[l("span",null,"            } else {")]),n(`
`),l("span",{class:"line"},[l("span",null,"                set.remove(s.charAt(left));")]),n(`
`),l("span",{class:"line"},[l("span",null,"                left++;")]),n(`
`),l("span",{class:"line"},[l("span",null,"            }")]),n(`
`),l("span",{class:"line"},[l("span",null,"        }")]),n(`
`),l("span",{class:"line"},[l("span",null,"        return maxLen;")]),n(`
`),l("span",{class:"line"},[l("span",null,"    }")]),n(`
`),l("span",{class:"line"},[l("span",null,"}")])])]),l("button",{class:"collapse"})],-1),l("h4",{id:"方法2-优化实现-跳转左指针",tabindex:"-1"},[n("方法2：优化实现（跳转左指针） "),l("a",{class:"header-anchor",href:"#方法2-优化实现-跳转左指针","aria-label":'Permalink to "方法2：优化实现（跳转左指针）"'},"​")],-1),l("p",null,"java",-1),l("div",{class:"language- vp-adaptive-theme"},[l("button",{title:"Copy Code",class:"copy"}),l("span",{class:"lang"}),l("pre",{class:"shiki shiki-themes github-light github-dark vp-code"},[l("code",{"v-pre":""},[l("span",{class:"line"},[l("span",null,"class Solution {")]),n(`
`),l("span",{class:"line"},[l("span",null,"    public int lengthOfLongestSubstring(String s) {")]),n(`
`),l("span",{class:"line"},[l("span",null,"        Map<Character, Integer> map = new HashMap<>();")]),n(`
`),l("span",{class:"line"},[l("span",null,"        int maxLen = 0, left = 0;")]),n(`
`),l("span",{class:"line"},[l("span",null,"        for (int right = 0; right < s.length(); right++) {")]),n(`
`),l("span",{class:"line"},[l("span",null,"            char c = s.charAt(right);")]),n(`
`),l("span",{class:"line"},[l("span",null,"            if (map.containsKey(c)) {")]),n(`
`),l("span",{class:"line"},[l("span",null,"                left = Math.max(left, map.get(c) + 1);")]),n(`
`),l("span",{class:"line"},[l("span",null,"            }")]),n(`
`),l("span",{class:"line"},[l("span",null,"            map.put(c, right);")]),n(`
`),l("span",{class:"line"},[l("span",null,"            maxLen = Math.max(maxLen, right - left + 1);")]),n(`
`),l("span",{class:"line"},[l("span",null,"        }")]),n(`
`),l("span",{class:"line"},[l("span",null,"        return maxLen;")]),n(`
`),l("span",{class:"line"},[l("span",null,"    }")]),n(`
`),l("span",{class:"line"},[l("span",null,"}")])])]),l("button",{class:"collapse"})],-1),l("h3",{id:"算法分析",tabindex:"-1"},[n("算法分析 "),l("a",{class:"header-anchor",href:"#算法分析","aria-label":'Permalink to "算法分析"'},"​")],-1),l("table",null,[l("thead",null,[l("tr",null,[l("th",{style:{"text-align":"left"}},"方法"),l("th",{style:{"text-align":"left"}},"时间复杂度"),l("th",{style:{"text-align":"left"}},"空间复杂度"),l("th",{style:{"text-align":"left"}},"优势")])]),l("tbody",null,[l("tr",null,[l("td",{style:{"text-align":"left"}},"基础实现"),l("td",{style:{"text-align":"left"}},"O(n)"),l("td",{style:{"text-align":"left"}},"O(1)"),l("td",{style:{"text-align":"left"}},"逻辑简单，易于理解")]),l("tr",null,[l("td",{style:{"text-align":"left"}},"优化实现"),l("td",{style:{"text-align":"left"}},"O(n)"),l("td",{style:{"text-align":"left"}},"O(1)"),l("td",{style:{"text-align":"left"}},"减少左指针移动次数，效率更高")])])],-1),l("blockquote",null,[l("p",null,[l("strong",null,"说明"),n("：空间复杂度 O(1) 是因为字符集大小固定（ASCII 字符最多 128 个）")])],-1),l("h3",{id:"关键点总结",tabindex:"-1"},[n("关键点总结 "),l("a",{class:"header-anchor",href:"#关键点总结","aria-label":'Permalink to "关键点总结"'},"​")],-1),l("ol",null,[l("li",null,[l("strong",null,"滑动窗口核心思想"),n("： "),l("ul",null,[l("li",null,[l("strong",null,"右指针"),n("：探索新字符，扩展窗口")]),l("li",null,[l("strong",null,"左指针"),n("：移除重复字符，收缩窗口")])])]),l("li",null,[l("strong",null,"优化核心"),n("： "),l("ul",null,[l("li",null,"通过记录字符最后位置实现左指针跳转"),l("li",null,"避免不必要的逐步移动，提升效率")])]),l("li",null,[l("strong",null,"终止条件"),n("：右指针到达字符串末尾")]),l("li",null,[l("strong",null,"结果更新"),n("：每次扩展窗口后更新最大长度")])],-1),l("h3",{id:"适用问题场景",tabindex:"-1"},[n("适用问题场景 "),l("a",{class:"header-anchor",href:"#适用问题场景","aria-label":'Permalink to "适用问题场景"'},"​")],-1),l("p",null,"滑动窗口算法特别适合解决以下类型问题：",-1),l("ul",null,[l("li",null,"子串/子数组的最值问题（如本题）"),l("li",null,"满足特定条件的连续子序列问题"),l("li",null,"需要高效遍历数组/字符串的场景")],-1),l("p",null,"通过掌握滑动窗口算法，可以高效解决一大类字符串和数组相关的面试题！",-1)])),"main-header":a(()=>[t(e.$slots,"main-header")]),"main-header-after":a(()=>[t(e.$slots,"main-header-after")]),"main-nav":a(()=>[t(e.$slots,"main-nav")]),"main-content-before":a(()=>[t(e.$slots,"main-content-before")]),"main-content":a(()=>[t(e.$slots,"main-content")]),"main-content-after":a(()=>[t(e.$slots,"main-content-after")]),"main-nav-before":a(()=>[t(e.$slots,"main-nav-before")]),"main-nav-after":a(()=>[t(e.$slots,"main-nav-after")]),comment:a(()=>[t(e.$slots,"comment")]),footer:a(()=>[t(e.$slots,"footer")]),aside:a(()=>[t(e.$slots,"aside")]),"aside-custom":a(()=>[t(e.$slots,"aside-custom")]),default:a(()=>[t(e.$slots,"default")]),_:3},8,["frontmatter"])}}};export{D as default,$ as usePageData};
